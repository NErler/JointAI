#' Extract id variable from random effects formula
#' @param random a formula describing random effects structure
#' @return a character string, giving the name of the id variable or NULL
#' @export
extract_id <- function(random) {
  idmatch <- regexpr(pattern = "[[:print:]]*\\|[[:space:]]*",
                     deparse(random, width.cutoff = 500))
  if (idmatch > 0) {
    id <- unlist(regmatches(deparse(random, width.cutoff = 500),
                            idmatch, invert = T))
    id <- id[id != ""]
  } else {
    id <- NULL
  }

  if (is.null(id) & !is.null(random))
    warning(paste0("\nNo id variable could be identified.\n",
                   "I'll assume that all observations are independent."),
            call. = F, immediate. = T)
  return(id)
}


#' Extract outcome variable from fixed effects formula
#' @param fixed a formula describing fixed effects structure
#' @return a character string, giving the name of the outcome variable
#' @export
extract_y <- function(fixed) {
  if (!inherits(fixed, "formula")) {
    fixed <- as.formula(fixed)
  }
  y <- sub("[[:space:]]*\\~[[:print:]]*", "",
           deparse(fixed, width.cutoff = 500))
  if (y == "" | is.na(y) | is.null(y)) {
    stop("\nUnable to extract the outcome variable.")
  }
  return(y)
}


#' Remove grouping from formula
#' @param fmla a formula object or a string describing a formula
#' @return returns the formula without the grouping part, i.e., with out
#'         anything behind "|"
#' @export
remove_grouping <- function(fmla){
  if (is.null(fmla)) return(NULL)

  fmla2 <- sub("[[:space:]]*\\|[[:print:]]*", "",
               deparse(fmla, width.cutoff = 500))
  if (class(fmla) == "formula") {
    as.formula(fmla2)
  } else {
    fmla2
  }
}



#' Check if a variable is time-varying
#' @param x a vector, the variable to be tested
#' @param idvar a vector specifying a grouping
#' @return a logical value
#' @export
check_tvar <- function(x, idvar) {
  !all(sapply(split(x, idvar),
              function(z) all(z == z[1], na.rm = T)
  )
  )
}


#' Find position of variable names in a vector of variable names
#' @param nams1 vector of variable name to look for
#' @param nams2 vector of variable names
#' @return integer
#' @export
find_positions <- function(nams1, nams2) {
  nams1 <- gsub("^", "\\^", nams1, fixed = TRUE)
  vals <- c(glob2rx(nams1), glob2rx(paste0(nams1, ":*")),
            glob2rx(paste0("*:", nams1)))
  out <- unique(unlist(lapply(vals, grep, x = nams2)))
  out
}



#' Find the position(s) of a variable in a model matrix
#' @param varname character string to look for
#' @param DF data frame containing the variable
#' @param colnams column names of model matrix
#' @return named vector specifying the columns in X that relate to varname
#' @export
match_positions <- function(varname, DF, colnams) {
  if (is.factor(DF[, varname])) {
    contr <- list("contr.treatment")
    names(contr) <- varname
  } else {
    contr <- NULL
  }

  matches <- match(colnames(model.matrix(formula(paste("~", varname)),
                                         DF,
                                         contrasts.arg = contr))[-1L],
                   colnams)
  names(matches) <- colnams[matches]
  return(if (any(!is.na(matches))) matches)
}



prep_name <- function(nam) {
  glob2rx(gsub("^", "\\^", nam, fixed = T))
}

#' Generate pattern (used in get_hc_list)
#' @param nam variable name (character string)
#' @return vector
gen_pat <- function(nam) {
  nam <- gsub("^", "\\^", nam, fixed = T)
  glob2rx(c(nam,
            paste0("*:", nam),
            paste0(nam, ":*")), trim.head = T)
}

#' Find names in a vector of names (used in get_hc_list)
#' @param nams1 the names to look for (generated by gen_pat)
#' @param nams2 the vector of names to search in
grep_names <- function(nams1, nams2){
  res <- unique(unlist(sapply(nams1, grep, nams2, value = T, simplify = F)))
  if (length(res) > 0) res
}


#' Hierarchical centering structure
#' @param X2_names vector of column names in the extended fixed effects design matrix
#' @param Z_names vector of column names of the random effects design matrix
#' @param Xc_names vector of column names of the matrix of baseline covariates
#' @return A named list with an entry for each level of random effects, omitting
#'         the random intercept. Each list entry is a named vector, where the
#'         names represent the variable names of either the main effect of a
#'         variable that is part of the random and fixed effects structure, or
#'         the name of a variable that has an interaction with the variable for
#'         which there is a random effect. The values represent the column
#'         number of the respective matrix for the variable (for interaction terms
#'         the column number of the variable that is not the respective
#'         random effect). The attribute
#'         "matrix" names the matrix (Z or Xc), and is NA when the variable
#'         is not in either of the two matrices.
#'
#' @export
# get_hc_list <- function(X2_names, Xc_names, Z_names) {
# hc_vars <- hc_list <- if (length(Z_names) > 1) {
#   lapply(sapply(Z_names[-1], gen_pat, simplify = F),
#          grep_names, X2_names)
# }
# for (i in 1:length(hc_vars)) {
#   if (length(hc_vars[[i]]) > 0) {
#     matchvars <- gsub(paste(gen_pat(names(hc_vars)[i]), collapse = "|"),
#                       "", hc_vars[[i]])
#
#     a <- character(length(matchvars))
#     hc_vec <- NA
#     for (j in 1:length(matchvars)) {
#       if (is.na(matchvars[j])) {
#         a[j] <- NA
#         hc_vec[j] <- NA
#       } else {
#         if (matchvars[j] == "") {
#           a[j] <- "Z"
#           hc_vec[j] <- NA # match(names(hc_vars)[i], Z_names)
#         } else {
#           a[j] <- if (matchvars[j] %in% Xc_names) "Xc" else NA
#           hc_vec[j] <- match(matchvars[j], Xc_names)
#         }
#       }
#     }
#     attr(hc_vec, "matrix") <- a
#     names(hc_vec) <- hc_vars[[i]]
#
#     hc_list[[i]] <- hc_vec
#   }
# }
get_hc_list <- function(X2, Xc, Xic, Z, Xlong) {
  hc_vars <- hc_list <- if (ncol(Z) > 1) {
    lapply(sapply(colnames(Z)[-1], gen_pat, simplify = F),
           grep_names, colnames(X2))
  }
  for (i in 1:length(hc_vars)) {
    if (length(hc_vars[[i]]) > 0) {
      matchvars <- gsub(paste(gen_pat(names(hc_vars)[i]), collapse = "|"),
                        "", hc_vars[[i]])

      a <- sapply(
        apply(
          as.array(sapply(
            lapply(list(Xc = Xc, Xic = Xic, Z = Z, Xlong = Xlong), colnames),
            FUN = function(x) matchvars %in% x)), 1, which), names)


      a[matchvars == ""] <- "Z"
      a <- unlist(a)
      names(a) <- hc_vars[[i]]

      pos <- mapply(FUN = function(i, i_nam) {
        match(i_nam, lapply(list(Xc = Xc, Xic = Xic, Z = Z, Xlong = Xlong), colnames)[[i]])
      }, i = a, i_nam = matchvars)

      attr(pos, "matrix") <- a
      hc_list[[i]] <- pos
    }
  }
  return(hc_list)
}



capitalize <- function(string)
{
  capped <- grep("^[^A-Z]*$", string, perl = TRUE)
  substr(string[capped], 1, 1) <- toupper(substr(string[capped],
                                                 1, 1))
  return(string)
}


scaled_data.matrix <- function(X, scale_vars, scale_pars) {
  if (any(scale_pars == F, scale_vars == F))
    scale_pars <- scale_vars <- F

  if (is.matrix(scale_pars)) {
    if (any(colnames(X) %in% colnames(scale_pars))) {
      X[, colnames(scale_pars)] <-
        sapply(colnames(scale_pars),
               function(x) (x - scale_pars["center", x])/scale_pars["scale", x]
        )
    }
  } else {
    if (is.null(scale_pars) & any(colnames(X) %in% scale_vars)) {
      scale_pars <- list()
      for (i in scale_vars[scale_vars %in% colnames(X)]) {
        scv <- scale(X[, i])
        X[, i] <- scv
        scale_pars[[i]] <- c(center = attr(scv, "scaled:center"),
                             scale = attr(scv, "scaled:scale"))
      }
    } else {
      scale_pars <- NULL
    }

  }
  return(list(X = data.matrix(X), scale_pars = scale_pars))
}


#' Function to find the names of columns in the model matrix that involve
#' continuous covariates (and hence may need to be scaled)
#' for now not used
find_continuous <- function(fixed, DF, contr = NULL) {
  # remove left side of formula
  fmla <- as.formula(sub("[[:print:]]*\\~", "~",
                         deparse(fixed, width.cutoff = 500)))

  # check which variables involved are continuous
  is_continuous <- !sapply(DF[, all.vars(fmla)], is.factor)

  elmts <- attr(terms(fmla), "term.labels")

  fixed_c <- as.formula(
    paste("~",
          paste(elmts[unique(unlist(sapply(names(is_continuous)[is_continuous],
                                           grep, elmts)))],
                collapse = " + ")
    )
  )

  colnames(model.matrix(fixed_c, DF, contrasts.arg = contr)[, -1L , drop = F])
}


#' Function to find the names of columns in the model matrix that involve
#' continuous covariates (and hence may need to be scaled) - only main effects
find_continuous_main <- function(fixed, DF) {
  # remove left side of formula
  fmla <- as.formula(sub("[[:print:]]*\\~", "~",
                         deparse(fixed, width.cutoff = 500)))

  # check which variables involved are continuous
  is_continuous <- !sapply(model.frame(fmla, DF), is.factor)

  names(is_continuous)[is_continuous]
}


#' Split an * in a formula into + and :
split_interaction <- function(x) {
  elmts <- strsplit(x, "[*]")[[1]]
  paste(c(elmts, paste(elmts, collapse = ":")), collapse = " + ")
}

